import torch
import scipy.optimize as opt
import numpy as np
from multiprocessing import Pool

def hungarian(s: torch.Tensor, n1=None, n2=None, mask=None, nproc=1):
    """
    Solve optimal LAP permutation by hungarian algorithm.
    :param s: input 3d tensor (first dimension represents batch)
    :param n1: [num of objs in dim1] (against padding)
    :param n2: [num of objs in dim2] (against padding)
    :param nproc: number of parallel processes (default =1 for no parallel)
    :return: optimal permutation matrix
    """
    if len(s.shape) == 2:
        s = s.unsqueeze(0)
        matrix_input = True
    elif len(s.shape) == 3:
        matrix_input = False
    else:
        raise ValueError('input data shape not understood.')

    device = s.device
    batch_num = s.shape[0]

    perm_mat = s.cpu().detach().numpy() * -1
    if n1 is not None:
        n1 = n1.cpu().numpy()
    else:
        n1 = [None] * batch_num
    if n2 is not None:
        n2 = n2.cpu().numpy()
    else:
        n2 = [None] * batch_num
    if mask is None:
        mask = [None] * batch_num

    if nproc > 1:
        with Pool(processes=nproc) as pool:
            mapresult = pool.starmap_async(hung_kernel, zip(perm_mat, n1, n2))
            perm_mat = np.stack(mapresult.get())
    else:
        perm_mat = np.stack([hung_kernel(perm_mat[b], n1[b], n2[b], mask[b]) for b in range(batch_num)])

    perm_mat = torch.from_numpy(perm_mat).to(device)

    if matrix_input:
        perm_mat.squeeze_(0)

    return perm_mat

def hung_kernel(s: torch.Tensor, n1=None, n2=None, mask=None):
    if mask is None:
        if n1 is None:
            n1 = s.shape[0]
        if n2 is None:
            n2 = s.shape[1]
        row, col = opt.linear_sum_assignment(s[:n1, :n2])
    else:
        mask = mask.cpu()
        s_mask = s[mask]
        if s_mask.size > 0:
            dim0 = torch.sum(mask, dim=0).max()
            dim1 = torch.sum(mask, dim=1).max()
            row, col = opt.linear_sum_assignment(s_mask.reshape(dim0, dim1))
            row = torch.nonzero(torch.sum(mask, dim=1), as_tuple=True)[0][row]
            col = torch.nonzero(torch.sum(mask, dim=0), as_tuple=True)[0][col]
        else:
            row, col = [], []
    perm_mat = np.zeros_like(s)
    perm_mat[row, col] = 1
    return perm_mat